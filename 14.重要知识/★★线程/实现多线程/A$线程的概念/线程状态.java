package A$线程的概念;
/**
 * 
 * 
 * 新生状态
 * 		用new关键字和Thread类或者其子类建立一个线程对象后，该线程对象就处于新生状态，。处于新生状态的线程有自己的
 * 内存空间，通过调用start方法进入就绪状态（runnable）
 * 
 * 就绪状态
 * 		处于就绪状态的线程已经具备了运动条件，但还没有分配到CPU，处于线程就绪队列，等待系统为其分配CPU，等待状态
 * 并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的行为称之为
 * “CPU调度”，一旦获得CPU，线程就进入运行状态并自动调用自己的run方法
 * 
 * 运行状态：
 * 		在运行状态的线程执行自己的run方法中代码，直到调用其他方法而终止，或者等待某资源而阻塞或者完成任务而死亡如
 * 果给定的时间片内没有执行结束，就会被系统给换下来回到执行等待状态
 * 
 * 阻塞状态：
 * 		处于运行状态的线程在某些情况下，如执行了sleep()（睡眠）方法，或者等待I/O设备等资源将会让出CPU并暂时停止自
 * 己的运行并进入阻塞状态。在阻塞状态的线程不能进入就绪队列，只有当引起阻塞的原因消除时，如睡眠时间已到，或者等待的
 * I/O设备空闲下来，线程便转入就就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行
 * 
 * 死亡状态
 * 		死亡状态时线程生命周期的最后一个阶段，线程死亡的原因有两个，一个是正常运行的线程完成了它全部的工作，另一个
 * 是线程被强制的结束，如通过执行stop或者destroy方法来终止一个线程（不推荐使用这两个方法。前者会产生异常，后者是
 * 强制终止，不会释放锁），推荐自己写
 *
 *
 * *二，手动停止线程
 	* 1，自然终止：线程体正常执行完毕
 	* 2，外部干涉：
 	* 1）线程类中 定义线程使用时的标识
 	* 2）线程体使用该标志
 	* 3) 提供对外的方法改变该标识
 	* 4）外部干涉根据条件调用方法结束即可
 * 
 * 三，阻塞
 	* 1)ioin 合并线程
 	* 2)yield 暂停自己的线程，static 方法
 	* 3)sleep休眠，休眠的时候不会释放锁，常用于“模拟倒计时”，“模拟网络延迟”等与时间有关的
 *
 */
public class 线程状态 {}

